
\documentclass[12pt]{article}
\usepackage[paper=letterpaper,margin=2cm]{geometry}

\usepackage{amsmath}
\usepackage{amsthm} %needed for the proofs 
\usepackage{amssymb}

\usepackage{titling}
\usepackage{thmtools}
\usepackage{mathptmx} %font

%\usepackage{algpseudocode} % for algorithm pseudo code
%\usepackage{algorithm}
%\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%macros for recursive functions
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKwFunction{FRecurs}{MaxSubArray}%
\SetKwProg{Fn}{Function }{\string:}{}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
%For plots
\usepackage{pgfplots}
\pgfplotsset{compat = newest}

\newtheorem{theorem}{Theorem}
\declaretheoremstyle{lemma}
\declaretheorem[style=lemma, name=Lemma]{lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\declaretheoremstyle{example}
\declaretheorem[style=example, name=Example]{example}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\declaretheoremstyle{proposition}
\declaretheorem[style=proposition, name=Proposition]{proposition}

\declaretheorem[name=Note]{note}
\declaretheoremstyle{note}

\newcommand\sol{%
  \\ 
  \\
  \textit{Solution:}\\%
}

\setlength{\droptitle}{-6em}

\title{\textsc{Assignment 1 -- Comp 252}}  
\author{Alexandre St-Aubin}
\date{\today}

\begin{document}
\maketitle 
\begin{enumerate}
  \item[\it Exercise 1] Consider a Fibonacci sequence starting with $x_0 = 0,\; x_1 = 1$. For positive integers $k$ and $n$, we would like to compute $x_n \mod k$ and are using the ram model of computation in which standard arithmetic operations, including “mod” take constant time. Describe how you would proceed in two cases: (1) $k = 627$, (2) $k = n$. In both cases, give your complexity in $O(\cdot)$.
  \sol  
  Case $(1)$: It is known that for any integer $k,$ the sequence of \textit{Fibonacci} numbers modulo $k$ has a period. Let $\pi (k)$, the \textit{Pisano Period, }denote the length of this period. A list of the \textit{Fibonacci} sequence modulo 627 of length $\pi (627)$ can be computed beforehand. 

\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{The Pisano Period $pisanoPeriod$ for $k= 627$, an array $fibSeqMod$ of the first $pisanoPeriod$ integers of the Fibonacci sequence modulo 627, and the index $n$ of the Fibonacci sequence.}
\Output{$x_n \mod 627$}
\BlankLine
  {$x \leftarrow n \mod pisanoPeriod$}
\caption{Find the Fibonacci sequence number $x_n$ modulo 627. }\label{algo_disjdecomp}
  \KwRet{$fibSeqMod [x]$}
\end{algorithm}\DecMargin{1em}
  Note that in this first case, the Pisano period and in particular, the first $\pi (627)$ elements modulo $627$ of the Fibonacci sequence are constant, no matter the input $n$. It follows that the time complexity is 
  $$O(1) $$
  Case (2): 

\begin{algorithm}
  \caption{Fibonacci Modulo N}\label{algo:fibonacci_modulo_n}
\SetKwFunction{Fib}{fib}
\SetKwFunction{Multiply}{multiply}
\SetKwFunction{Power}{power}

\KwSty{Function \Fib{$(n)$}:}{\\
    $F \leftarrow [[1,1],[1,0]]$\;
    \If{$n == 0$}{
        \KwRet $0$\;
    }
    \Power{$(F, n - 1)$}\;
    \KwRet $F[0][0]$\;
}
\BlankLine
\KwSty{Function \Multiply{$(F, M)$}:}{\\
    $x \leftarrow F[0][0] \cdot M[0][0] + F[0][1] \cdot M[1][0]$\;
    $y \leftarrow F[0][0] \cdot M[0][1] + F[0][1] \cdot M[1][1]$\;
    $z \leftarrow F[1][0] \cdot M[0][0] + F[1][1] \cdot M[1][0]$\;
    $w \leftarrow F[1][0] \cdot M[0][1] + F[1][1] \cdot M[1][1]$\;
    
    $F[0][0] \leftarrow x$\;
    $F[0][1] \leftarrow y$\;
    $F[1][0] \leftarrow z$\;
    $F[1][1] \leftarrow w$\;
}
\BlankLine

\KwSty{Function \Power{$(F, n)$}:}{\\
    \If{$n == 0$ or $n == 1$}{
        \KwRet\;
    }
    $M \leftarrow [[1,1],[1,0]]$\;
    \Power{$(F, n // 2)$}\;
    \Multiply{$(F, F)$}\;
    \If{$n$ is odd}{
        \Multiply{$(F, M)$}\;
    }
}
\end{algorithm}

\newpage
\item[\it Exercise 2] In the bit model of computation, give an efficient algorithm for determining whether a given integer $n$ is a perfect square, and determine its worst-case complexity in big oh notation as a function of $n$.
\sol  
\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}

\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{An integer $n$.}
\Output{True or False.}
\BlankLine
$left \leftarrow 1$ \\ 
$right \leftarrow n$ \\ 
  \While{$left\leq right$}{
  $mid \leftarrow left + \lfloor(right-left)/2\rfloor $ \\ 
  $mid\_squared = mid* mid$\\
  \eIf{$n = mid\_squared$}{
  \Return True
  }{
  \uIf{$n<mid\_squared $}{
  $right \leftarrow mid-1$
  }\uElseIf{$n>mid\_squared $}{
  $left \leftarrow mid + 1$  
  }
  }
  }\Return False

\caption{Check whether an integer $n$ is a perfect square. }\label{algo_disjdecomp}
\end{algorithm}\DecMargin{1em}


We now determine the above algorithm's worst case time complexity in the bit model, denoting it $T_n$. In the worst case, line \textbf{3} will run $\log_2 n$ times, let $i$ be the iteration number. We safely estimate that in the worst case, at iteration $i,$ we have, $$|mid|= \lfloor \log_2 n \rfloor + 1$$ 
where $|\cdot |$ denotes the bit length of an integer. Now, we don't need to worry about the additions in each iteration, as they take linear time and are dwarfed by the multiplications/divisions, which take quadratic time. Hence, we conclude that the worst case time complexity in the bit model for this algorithm is 
$$T_n = O(\underbrace{\log_2 n}_{\text{\# of iterations}} \times \underbrace{(\log_2 n)^2}_{\text{multiplication}}) = O((\log_2 n )^3) $$
\newpage 
\item[\it Exercise 3] Assuming a \textsc{ram} (uniform cost) model of computation, design a recursive divide-and-conquer style $O(n)$ worst-case time algorithm for the following problem. We are given an array $x[1],... , x[n]$ of (possibly negative) integers, and are asked to find two indices $i \leq j$ such that $ x[i] +...+ x[j]$ is maximal. Prove your claim.
\sol 
\IncMargin{1em}
\begin{algorithm}

\caption{Maximum Subarray recursive, divide-and-conquer algorithm. }\label{algo_disjdecomp}
\Input{An array of integers $arr$, and its length $len$.}
\Output{Two integers, $first, \; last$, representing the first and last index of the maximal subarray.}
  $tempSum \leftarrow arr[0]$\\ 
$maxSum \leftarrow -\infty$ \\ 
$j \leftarrow 0$\\ 
$first \leftarrow 0$ \\ 
$last \leftarrow 0$\\ 

  \textsc{MaxSubArray}$(1)$ \\
  \BlankLine

  \Fn{\textsc{MaxSubArray}$(i)$}{
  \eIf{$tempSum + arr[i] \geq tempSum$ }{
  $tempSum \leftarrow tempSum + arr[i]$\\ 
  }{
  \If{$tempSum > maxSum$}{
  $maxSum \leftarrow tempSum$\\ 
  $last \leftarrow i-1$ \\ 
  $first \leftarrow j$
  }
  $tempSum \leftarrow 0$ \\ 
  $j \leftarrow i + 1$ \\
  }
  \If{$i<len$}{
  \textsc{MaxSubArray}$(i+1)$
  }
}
\end{algorithm}\DecMargin{1em}


To justify that this algorithm has a worst-case time complexity $O(n)$, one only needs to observe that in any case, the array will be traversed exactly once, performing a constant number of operations at each index.

\end{enumerate}
\end{document}
