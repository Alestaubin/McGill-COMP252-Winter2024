
\documentclass[12pt]{article}
\usepackage[paper=letterpaper,margin=2cm]{geometry}

\usepackage{amsmath}
\usepackage{amsthm} %needed for the proofs 
\usepackage{amssymb}

\usepackage{titling}
\usepackage{thmtools}
\usepackage{mathptmx} %font
\usepackage{verbatim} % for comments

%\usepackage{algpseudocode} % for algorithm pseudo code
%\usepackage{algorithm}
%\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%macros for recursive functions
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKwFunction{FRecurs}{MaxSubArray}%
\SetKwProg{Fn}{Function }{\string:}{}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
%For plots
\usepackage{pgfplots}
\pgfplotsset{compat = newest}

\newtheorem{theorem}{Theorem}
\declaretheoremstyle{lemma}
\declaretheorem[style=lemma, name=Lemma]{lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\declaretheoremstyle{example}
\declaretheorem[style=example, name=Example]{example}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\declaretheoremstyle{proposition}
\declaretheorem[style=proposition, name=Proposition]{proposition}

\declaretheorem[name=Note]{note}
\declaretheoremstyle{note}

\newcommand\sol{%
  \\ 
  \\
  \textit{Solution:}\\%
}

\setlength{\droptitle}{-6em}

\title{\textsc{Assignment 1 -- Comp 252}}  
\author{Alexandre St-Aubin}
\date{\today}

\begin{document}
\maketitle 
\begin{enumerate}
  \item[\it Exercise 1] Consider a Fibonacci sequence starting with $x_0 = 0,\; x_1 = 1$. For positive integers $k$ and $n$, we would like to compute $x_n \mod k$ and are using the ram model of computation in which standard arithmetic operations, including “mod” take constant time. Describe how you would proceed in two cases: (1) $k = 627$, (2) $k = n$. In both cases, give your complexity in $O(\cdot)$.
  \sol  
  Case $(1)$: It is known that for any integer $k,$ the sequence of \textit{Fibonacci} numbers modulo $k$ has a period. Let $\pi (k)$, the \textit{Pisano Period, }denote the length of this period. A list of the \textit{Fibonacci} sequence modulo 627 of length $\pi (627)$ can be computed beforehand. 

\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{The Pisano Period $pisanoPeriod$ for $k= 627$, an array $fibSeqMod$ of the first $pisanoPeriod$ integers of the Fibonacci sequence modulo 627, and the index $n$ of the Fibonacci sequence.}
\Output{$x_n \mod 627$}
\BlankLine
  {$x \leftarrow n \mod pisanoPeriod$}
\caption{Find the Fibonacci sequence number $x_n$ modulo 627. }\label{algo_disjdecomp}
  \KwRet{$fibSeqMod [x]$}
\end{algorithm}\DecMargin{1em}
  Note that in this first case, the Pisano period and in particular, the first $\pi (627)$ elements modulo $627$ of the Fibonacci sequence are constant, no matter the input $n$. It follows that the time complexity is 
  $$O(1) $$
  Case (2): 

\newpage
\item[\it Exercise 2] In the bit model of computation, give an efficient algorithm for determining whether a given integer $n$ is a perfect square, and determine its worst-case complexity in big oh notation as a function of $n$.
\sol  
\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}

\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{An integer $n$.}
\Output{True or False.}
\BlankLine
$left \leftarrow 1$ \\ 
$right \leftarrow n$ \\ 
  \While{$left\leq right$}{
  $mid \leftarrow left + \lfloor(right-left)/2\rfloor $ \\ 
  $mid\_squared = mid* mid$\\
  \eIf{$n = mid\_squared$}{
  \Return True
  }{
  \uIf{$n<mid\_squared $}{
  $right \leftarrow mid-1$
  }\uElseIf{$n>mid\_squared $}{
  $left \leftarrow mid + 1$  
  }
  }
  }\Return False

\caption{Check whether an integer $n$ is a perfect square. }\label{algo_disjdecomp}
\end{algorithm}\DecMargin{1em}


We now determine the above algorithm's worst case time complexity in the bit model, denoting it $T_n$. In the worst case, line \textbf{3} will run $\log_2 n$ times, let $i$ be the iteration number. We safely estimate that in the worst case, at iteration $i,$ we have, $$|mid|= \lfloor \log_2 n \rfloor + 1$$ 
where $|\cdot |$ denotes the bit length of an integer. Now, we don't need to worry about the additions in each iteration, as they take linear time and are dwarfed by the multiplications/divisions, which take quadratic time. Hence, we conclude that the worst case time complexity in the bit model for this algorithm is 
$$T_n = O(\underbrace{\log_2 n}_{\text{\# of iterations}} \times \underbrace{(\log_2 n)^2}_{\text{multiplication}}) = O((\log n )^3) $$
\newpage 
\item[\it Exercise 3] Assuming a \textsc{ram} (uniform cost) model of computation, design a recursive divide-and-conquer style $O(n)$ worst-case time algorithm for the following problem. We are given an array $x[1],... , x[n]$ of (possibly negative) integers, and are asked to find two indices $i \leq j$ such that $ x[i] +...+ x[j]$ is maximal. Prove your claim.
\sol 

\begin{comment}
\IncMargin{1em}
\begin{algorithm}

\caption{Maximum Subarray recursive, divide-and-conquer algorithm. }\label{algo_disjdecomp}
\Input{An array of integers $arr$, and its length $len$.}
\Output{Two integers, $first, \; last$, representing the first and last index of the maximal subarray.}
  $tempSum \leftarrow arr[0]$\\ 
$maxSum \leftarrow -\infty$ \\ 
$j \leftarrow 0$\\ 
$first \leftarrow 0$ \\ 
$last \leftarrow 0$\\ 

  \textsc{MaxSubArray}$(1)$ \\
  \BlankLine

  \Fn{\textsc{MaxSubArray}$(i)$}{
  \eIf{$tempSum + arr[i] \geq tempSum$ }{
  $tempSum \leftarrow tempSum + arr[i]$\\ 
  }{
  \If{$tempSum > maxSum$}{
  $maxSum \leftarrow tempSum$\\ 
  $last \leftarrow i-1$ \\ 
  $first \leftarrow j$
  }
  $tempSum \leftarrow 0$ \\ 
  $j \leftarrow i + 1$ \\
  }
  \If{$i<len$}{
  \textsc{MaxSubArray}$(i+1)$
  }
}
\end{algorithm}\DecMargin{1em}


To justify that this algorithm has a worst-case time complexity $O(n)$, one only needs to observe that in any case, the array will be traversed exactly once, performing a constant number of operations at each index.
\end{comment}



\IncMargin{1em}
\begin{algorithm}

\SetKwArray{pre}{prefixTupleArray}
\SetKwArray{suf}{suffixTupleArray}
\SetKwArray{arr}{arr}
\SetKwFunction{maxsubarray}{maxSubArray}
\caption{Maximum Subarray recursive, divide-and-conquer algorithm. }\label{algo_disjdecomp}
\Input{An array of integers \arr.}
\Output{Two integers, $first, \; last$, representing the first and last index of the maximal subarray.}
  \pre, \suf $\leftarrow \arr;$  \\  
\tcp{\pre and \suf are arrays of tuples, \pre[i][0] contains \arr[i]}
\For{$i \leftarrow 1$ \KwTo $\text{length(\arr)}-1$}{
            \pre[i][0] += $\max(0, \text{\pre}[i-1])$;\\ 
            \eIf{\text{\pre}$[i-1]\geq 0$ }{
              \pre[i][1]$\leftarrow \pre[i-1][1]$;
            }{
            \pre[i][1] $\leftarrow i$;
            }
        }

\For{$i \leftarrow \text{length(\arr)}-2$ \KwTo $-1$}{
            \suf[i][0] += $\max(0, \text{\suf}[i+1])$\;
            \eIf{\text{\suf}$[i+1]\geq 0$ }{
              \suf[i][1] $\leftarrow \suf[i+1][1]$;
            }{
            \suf[i][1] $\leftarrow i$;
            }
        }
        \tcp{\pre[i][1] will hold the beginning index of the max subarray ending at i and \suf[i][1] the ending index of the max subarray starting at i. }
  \Return \maxsubarray (\arr, 0, length(\arr));\\
  \Fn{\maxsubarray(array, left, right)}{
  \If{left = right}{
  \Return (array[left], (left, left)); \tcp{return a tuple}
  }
  $mid\leftarrow \lfloor (left + right)/2 \rfloor$;\\
  $ l \leftarrow \maxsubarray(array, left, mid)$;\\
  $r \leftarrow \maxsubarray(array, mid+1, right);$\\ 
  $ a \leftarrow (\pre[mid][0] + \suf[mid+1][0], (\pre[mid][1], \suf[mid+1][1]) ) $; \\   
  \Return 
  }
\end{algorithm}
\DecMargin{1em}
In the above algorithm, index $i$ of the prefix array will contain the maximal sum of a subarray ending at $i$, while that of the suffix array will contain the maximal sum of a subarray starting at $i$. The complexity for the computation of prefix is always $O(n)$, as we must loop through each element of the array, similarly for suffix. As for the function \textsc{MaxSubarray}, its recurrence is given by
$$T_n = 2T_{n/2} $$
\end{enumerate}
\end{document}
