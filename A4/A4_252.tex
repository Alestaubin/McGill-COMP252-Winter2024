
\documentclass[12pt]{article}
\usepackage[paper=letterpaper,margin=2cm]{geometry}

%\usepackage{coffeestains} %lmao

\usepackage{amsmath}
\usepackage{amsthm} %needed for the proofs 
\usepackage{amssymb}
\usepackage{titling}
\usepackage{thmtools}
\usepackage{mathptmx} %font
\usepackage{verbatim} % for comments
\usepackage{mdframed}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{lipsum}

% --- NAMES --- %
\newcommand{\nameone}{Alexandre St-Aubin}
\newcommand{\nametwo}{ and Jonathan Campana}
%images
\usepackage{graphicx}
\graphicspath{ {./images/} }
% to include an image, do: 
%    \begin{center}
%    \includegraphics[scale=0.20]{graph.jpg}
%    \end{center}
% OR: 
%\begin{figure}
%    \centering
%    \includegraphics[scale=0.20]{IMG_1052.jpg}
%    \caption{Your caption text here.}
%\end{figure}


%For plots
\usepackage{pgfplots}
\pgfplotsset{compat = newest}

% --- Custom Math Commands --- %
\newtheorem{theorem}{Theorem}
\declaretheoremstyle{lemma}
\declaretheorem[style=lemma, name=Lemma]{lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\declaretheoremstyle{example}
\declaretheorem[style=example, name=Example]{example}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\declaretheoremstyle{proposition}
\declaretheorem[style=proposition, name=Proposition]{proposition}

\declaretheorem[name=Note]{note}
\declaretheoremstyle{note}

\newenvironment{ftheo}
  {\begin{mdframed}\begin{theorem}}
  {\end{theorem}\end{mdframed}}


  % --- Special commands --- %
\newcommand\sol{%
  \\ 
  \\
  \textit{Solution:}\\%
}
% Statistics
\newcommand{\indep}{\perp \!\!\! \perp}
\DeclareMathOperator{\var}{Var}
\DeclareMathOperator{\cov}{Cov}

%Convex optimisation operators
\DeclareMathOperator{\epi}{epi}
\DeclareMathOperator{\lev}{lev}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\aff}{aff}
\DeclareMathOperator{\ri}{ri}
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\cl}{cl}


% --- Header --- %
%\renewcommand{\headrulewidth}{.4mm} % header line width

\usepackage[T1]{fontenc} %header
\usepackage[utf8]{inputenc}%header
\usepackage{geometry} %header
\usepackage{fancyhdr}%header
\usepackage{blindtext}
\usepackage{lastpage}

\pagestyle{fancy}
\fancyhf{}
\fancyhfoffset[L]{1cm} % left extra length
\fancyhfoffset[R]{1cm} % right extra length
\rhead{\today}
\lhead{\it \nameone \nametwo}
%\fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}

% --- Title Page --- % 
\setlength{\droptitle}{-6em}

\title{\textsc{Assignment 4 -- COMP 252}}  
\author{\it \nameone \nametwo}
\date{\today}

\begin{document}
\maketitle 
\thispagestyle{empty} %clear first page numbering
%\coffeestainA{0.9}{0.85}{-25}{5cm}{1.3cm}
\begin{enumerate}
  \item \textsc{Browsing the small elements in a red-black tree}.
  \newpage 
  \item \textsc{Greedy algorithm}. On a flat table, we have placed n disks of radii $r_1, ..., r_n$, numbered from left to right. We push them together without creating overlap, as in the figure below. Give an $O(n)$ time algorithm to compute the size of the smallest axis-aligned rectangle that can hold the disks.
  \sol 
  See the algorithm on the next page. We show that its complexity is $O(n)$. To begin, the outermost loop at line 8 iterates a total of $n$ times. The maximum number of elements pushed onto the stack is also $n$ (since at most one is pushed at each iteration), hence an equal number is removed, maintaining the overall $O(n)$ complexity. Finally, as we traverse through each circle once more at the end of the algorithm, the complexity remains $O(n)$.
  \begin{algorithm}
    \caption{Greedy circle packing}
    \SetKwProg{Fn}{Function }{\string:}{}
    \SetKwRepeat{Do}{do}{while} %do-while loop macro
    \SetKwInput{KwOut}{Output}
    \SetKwInput{KwIn}{Input}
    \SetKwFunction{rad}{Radius}
    \SetKwFunction{cen}{centre\_dist}
    \SetKwData{dec}{possible\_adjacent\_stack}
    \SetKwData{a}{a}
    \SetKwData{b}{b}
    \SetKwData{arr}{array}    
    \SetKwData{ltok}{left\_to\_circle}   
    \SetKwData{maxd}{max\_d}   
    \SetKwData{len}{length}  
    \SetKwData{wid}{Width}   
    \SetKwFunction{mn}{MAKENULL}
    \SetKwFunction{top}{TOP}
    \SetKwFunction{pop}{POP}
    \SetKwFunction{push}{PUSH}

    \KwIn{An ordered list $\Omega := \{1,2,3,...,n\}$ of $n$ circles. }
    \KwOut{The minimum width of a rectangle that can hold the disks.}
    \BlankLine

    \tcp{\color{blue}radius of the circle a}
    \Fn{\rad{circle \a}}{
        \Return radius of \a;
    }
    \BlankLine

    \tcp{\color{blue}distance between the centres of a and b if they are pushed together.}
    \Fn{\cen{circle \a, circle \b}}{
      \Return $ \sqrt{(\rad(a)+\rad(b))^2 -(\rad(a)-\rad(b))^2};$
    }
    \BlankLine 
    \tcp{\color{blue}largest subarray of $\Omega$ ending with $k$, decreasing in radii. }
    $\mn (\dec); $\\
    \BlankLine 
    \tcp{\color{blue}distance from the left side of the rectangle to circle at index}
    $\ltok[] \gets new \; \arr;$\\     
    \BlankLine
    $\ltok[0] \gets 0;$\\ 

    \For{$i\gets 1 \text{ to } n$}{
      \eIf{$i=1$}{
        $\ltok[i-1] \gets \rad(i);$\\
        $\push(i, \dec)$\\ 
      }{
        \tcp{\color{blue} initialize max distance between left side of rectangle and circle i to \rad(i) to account for the case where the circle would touch the side.}
        $\maxd \gets \rad(i);$\\
        \tcp{\color{blue} \pop each circle on the stack that's smaller than i.}
      \While{$\rad(\top{\dec}) \leq \rad(i)$}{
        $\maxd \gets \max\{\maxd, \ltok(\pop{\dec})+ \cen(i, \dec(j)) \} ;$
      }
      \tcp{\color{blue} check first circle that's larger, but keep it on the stack}
      $\maxd \gets \max\{\maxd, \ltok(\top{\dec})+ \cen(i, \dec(j)) \} ;$\\ 
      \tcp{\color{blue}push i to stack, keeping the decreasing order}
      $\push(i, \dec);$\\ 
        \tcp{\color{blue} \maxd is the distance from the left side of the rectangle to the center of circle i when it is pushed as much as possible without overlapping}
        $\ltok[i-1] \gets \maxd;$\\ 
      }
      }
    \tcp{ \color{blue} find the width}
    $\wid \gets 0;$\\ 
    \For {$i \gets n-1 \text{ to } 0$}{
      \If{$\ltok[i]+ \rad(i)>\wid$}{
          $\wid \gets\ltok[i]+ \rad(i);$\\ 
      }
    }\Return \wid;
    
  \end{algorithm}

\end{enumerate}
\end{document}
